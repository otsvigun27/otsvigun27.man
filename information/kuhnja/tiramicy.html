<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title> Корисна інформація </title>
    <link rel="stylesheet" href="../../styles/styles.css">
 </head>
   <body>
        <header>
        </header>
        <h1> Корисна інформація </h1>
         <nav>
            <ul class="topmenu">
               <li>
                  <a href="../../index.html"> Головна </a>
               </li>
               <li>
                  <a href="../information.html"> Корисна інформація </a>
                    <ul class="submenu">
                        <li>
                                   <a  href="javascript:void(0)"> Початок початку </a>
                                    <ul class="submenu1">
                                        <li>
                                       <a href="../turizm/arhitectura.html"> Змінні і типи даних в С++ </a>
                                    </li>
                                    <li>
                                       <a href="../turizm/religion.html"> Синтаксис умови </a>
                                    </li>
                                    <li>
                                       <a href="../turizm/prays.html"> Цикли </a>
                                    </li>
                             </ul>
                                </li>
                                 <li>
                                    <a  href="javascript:void(0)"> Масиви </a>
                                    <ul class="submenu">
                                      <li>
                                         <a href="../history/drevniirim.html"> Одновимірні </a>
                                      </li>
                                      <li>
                                            <a href="../history/srednieveka.html"> Сортування одновимірних масивів </a>
                                         </li>
                                         <li>
                                             <a href="../history/20and21.html"> Двовимірні </a>
                                         </li>
                                     </ul>
                               </li>    
                                </li>
                                <li>
                                   <a  href="javascript:void(0)"> Графи </a>
                                       <ul class="submenu">
                                         <li>
                                            <a href="pizza.html"> Пошук в глибину </a>
                                         </li>
                                         <li>
                                            <a href="lazania.html"> Пошук в ширину </a>
                                         </li>
                                         <li>
                                             <a href="javascript:void(0)"> Алгоритм Дейкстри </a>
                                         </li>
                                        </ul>
                                </li>
                            </ul>
                </li>
                <li>
                   <a href="../../about/about.html"> Поради </a>
                </li>
                <li>
                  <a href="../../contacts/contacts.html"> Цікава інформація</a>
                </li>
            </ul>
        </nav>
        <div class="wrapper">
       
        <main>
           <section class="text">
             <article>
               <div class="div2"> </div> 
		<p> Знаходження найкоротших шляхів від заданої вершини до всіх інших вершин алгоритмом Дейкстри </p>
		<p> Постановка задачі </p>
		<p> Дан орієнтований або неорієнтований зважений граф з n вершинами і m ребрами. Ваги всіх ребер невід'ємні. Вказана деяка стартова вершина s. Потрібно знайти довжини найкоротших шляхів з вершини s в усі інші вершини, а також надати спосіб виведення самих найкоротших шляхів. </p>
		<p> алгоритм
Тут описується алгоритм, який запропонував голландський дослідник Дейкстра (Dijkstra) в 1959 р </p>
		<p> Заведемо масив d [], в якому для кожної вершини v будемо зберігати поточну довжину d [v] найкоротшого шляху з s в v. Спочатку d [s] = 0, а для всіх інших вершин ця довжина дорівнює нескінченності (при реалізації на комп'ютері зазвичай в якості нескінченності вибирають просто досить велике число, свідомо більше можливої ​​довжини шляху)</p>
		<p> Крім того, для кожної вершини v будемо зберігати, позначена вона ще чи ні, тобто заведемо булевский масив u []. Спочатку все вершини не позначені</p>
		<p> Сам алгоритм Дейкстри складається з n ітерацій. На черговій ітерації вибирається вершина v з найменшою величиною d [v] серед ще не помічених</p>
		<p> Обрана таким чином вершина v відзначається поміченої. Далі, на поточному ітерації, з вершини v виробляються релаксації: проглядаються всі ребра (v, to), які виходять з вершини v, і для кожної такої вершини to алгоритм намагається поліпшити значення d [to].</p>
		<p> На цьому поточна ітерація закінчується, алгоритм переходить до наступної ітерації (знову вибирається вершина з найменшою величиною d, з неї виробляються релаксації, і т.д.). При цьому в кінці кінців, після n ітерацій, все вершини графа стануть поміченими, і алгоритм свою роботу завершує. Стверджується, що знайдені значення d [v] і є шукані довжини найкоротших шляхів з s в v.</p>
		<p> Варто зауважити, що, якщо не все вершини графа досяжні з вершини s, то значення d [v] для них так і залишаться нескінченними. Зрозуміло, що кілька останніх ітерацій алгоритму будуть якраз вибирати ці вершини, але ніякої корисної роботи виробляти ці ітерації НЕ будуть (оскільки нескінченне відстань не зможе прорелаксіровать інші, навіть теж нескінченні відстані). Тому алгоритм можна відразу зупиняти, як тільки в якості обраної вершини береться вершина з нескінченним відстанню.</p>
		<p> Реалізація</p>
		<p> const int INF = 1000000000;</p>
		<p> int main() {</p>
		<p> int n;</p>
		<p> ... чтение n ...</p>
		<p> vector < vector < pair<int,int> > > g (n);</p>
		<p> ... чтение графа ...</p>
		<p> int s = ...; // стартовая вершина</p>
		<p> vector<int> d (n, INF),  p (n);</p>
		<p> d[s] = 0;</p>
		<p> vector<char> u (n);</p>
		<p> for (int i=0; i<n; ++i) {</p>
		<p> int v = -1;</p>
		<p> for (int j=0; j<n; ++j)</p>
		<p> if (!u[j] && (v == -1 || d[j] < d[v]))</p>
		<p> v = j;</p>
		<p> if (d[v] == INF)</p>
		<p> break;</p>
		<p> u[v] = true;</p>
		<p> for (size_t j=0; j<g[v].size(); ++j) {</p>
		<p> int to = g[v][j].first,</p>
		<p> len = g[v][j].second;</p>
		<p> if (d[v] + len < d[to]) {</p>
		<p> d[to] = d[v] + len;</p>
		<p> p[to] = v;</p>
		<p> }</p>
		<p> }</p>
		<p> }</p>
		<p> }</p>
		<div clacc="div1">      
               </div>
                       
               </article>
         </section>
      </main>
        </div>
      <div class="clear"></div>
      <footer><div class="div1">© Цвігун Ольга</div></footer>  
      </body>
      </html>